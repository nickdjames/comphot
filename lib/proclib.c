#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "fitsio.h"
#include "proclib.h"

// return non-zero if images are not the same size
int checksize(long img1[2], long img2[2])
{
	if (img1[0] != img2[0])
		return 1;
	if (img1[1] != img2[1])
		return 2;
	return 0;
}

// Convert CIE 1932 XYZ to ?? RGB
// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
int XYZ_to_sRGB(float *r, float *g, float *b, float *x, float *y, float *z, long axes[2])
{
	const double  sRGB[3][3] = { {3.2404542, -1.5371385, -0.4985314}, {-0.9692660,  1.8760108,  0.0415560}, {0.0556434, -0.2040259,  1.0572252} };
	long pix;

	for (pix = 0; pix < axes[0]*axes[1]; pix++) {
		r[pix] = (float) (x[pix] * sRGB[0][0] + y[pix] * sRGB[0][1] + z[pix] * sRGB[0][2]);
		g[pix] = (float) (x[pix] * sRGB[1][0] + y[pix] * sRGB[1][1] + z[pix] * sRGB[1][2]);
		b[pix] = (float) (x[pix] * sRGB[2][0] + y[pix] * sRGB[2][1] + z[pix] * sRGB[2][2]);
	}

	return 0;
}

// create a new image based on the source header but with potentially different size and bitpix
void create_new_img_from_src(fitsfile *tgt, fitsfile *src, long axes[2], int bitpix)
{
	int status = 0;
	int i, nkeys;
	char card[FLEN_CARD];

	fits_create_img(tgt, bitpix, 2, axes, &status);
	if (status)
		fits_report_error(stderr, status);

	fits_get_hdrspace(src, &nkeys, NULL, &status);

	for (i = 1; i <= nkeys; i++)  {
		fits_read_record(src, i, card, &status); /* read keyword */
		if (fits_get_keyclass(card) > TYP_CMPRS_KEY)
			fits_write_record(tgt, card, &status);
	}
}

int write_as_new_fits(float *buf, long axes[2], const char *name, FITSDESC *fd)
{
	fitsfile *fout=NULL;
	int status = 0;
	long start[2];

	if (fits_create_file(&fout, name, &status)) {
	 	handle_status(&status, 0, "File access");
		return -1;
	}

        fits_create_img(fout, fd->bitpix, 2, axes, &status);
        if (status) {
                fits_report_error(stderr, status);
		return -1;
	}

	//SER_timestamp(name, timestamp);
	//fits_write_key(fout, TSTRING, "DATE-OBS", name, "start or end of exposure?", &status);
	//fits_write_key(fout, TDOUBLE, "EXPTIME", &exp, "Unknown", &status);
	fits_write_key(fout, TSTRING, "HISTORY", (void *) "Generated by proclib", NULL, &status);
	if (fd->comment)
		 fits_write_comment(fout, fd->comment, &status);

	// fits_write_comment(fout, hdr->FileID, &status);
	// snprintf(name, MAXPATH, "Raw SER frame timestamp %ld", timestamp);
	// fits_write_comment(fout, name, &status);

	if (fd->bitpix == USHORT_IMG)
		image_limit(buf, 65535, axes);
	start[0] = start[1] = 1;
	fits_write_pix(fout, TFLOAT, start, axes[0]*axes[1], buf, &status);
	handle_status(&status, 0, "Image frame");

	if (fout) {
		fits_close_file(fout, &status);
		handle_status(&status, 0, "Output image close");
	}

	return 0;
}


// add a constant value to an image
int add_const(float *a, float constval, long axes[2])
{
	long i;
	for (i = 0; i < (axes[0]*axes[1]); i++)
		a[i] += constval;

	return 0;
}

// Normalize image to have a mean level of 1.0
int normalize(float *buf, long axes[2])
{
	double sum;
	long i;
	sum = 0;
	for (i = 0; i < (axes[0]*axes[1]); i++)
		sum += buf[i];
	sum /= axes[0]*axes[1];
	for (i = 0; i < (axes[0]*axes[1]); i++)
		buf[i] /= (float) sum;
	return 0;
}


// add image a to image b with optional normalisation of the median
int image_add(float *a, float *b, long axes[2], int norm)
{
	long i;
	float med;

	if (norm)
		med = median(b, axes[0]*axes[1]);
	else
		med = 0;


	for (i = 0; i < (axes[0]*axes[1]); i++)
		a[i] += (b[i]-med);
	return 0;
}

// subtract image b from a with optional normalisation of the median
int image_sub(float *a, float *b, long axes[2], int norm)
{
	long i;
	float med;

	if (norm)
		med = median(b, axes[0]*axes[1]);
	else
		med = 0;


	for (i = 0; i < (axes[0]*axes[1]); i++)
		a[i] -= (b[i]-med);
	return 0;
}

// divide image a by image b
int image_div(float *a, float *b, long axes[2])
{
	long i;
	for (i = 0; i < (axes[0]*axes[1]); i++) {
		if (b[i] > 0)
			a[i] /= b[i];
		else
			a[i] = 0;
	}
	return 0;
}

// multiply image a by image b
int image_mult(float *a, float *b, long axes[2])
{
	long i;
	for (i = 0; i < (axes[0]*axes[1]); i++) {
		if (b[i] > 0)
			a[i] *= b[i];
		else
			a[i] = 0;
	}
	return 0;
}

int image_ped(float *a, int ped, long axes[2])
{
	long i;
	for (i = 0; i < (axes[0]*axes[1]); i++) {
		a[i] += ped;
	}
	return 0;
}


// Limit image pixles to 0..limit
int image_limit(float *a, float limit, long axes[2])
{
	long i;
	for (i = 0; i < (axes[0]*axes[1]); i++) {
		if (a[i] < 0)
			a[i] = 0;
		if (a[i] > limit)
			a[i] = limit;
	}
	return 0;
}

// in place image flip
int image_flip(float *img, long axes[2])
{
	long x, y;
	float *row;

	row = (float *) malloc(sizeof(float) * axes[0]);

	for (y = 0; y < axes[1]; y++) {
		for (x = 0; x < axes[0]; x++)
			row[axes[0]-1-x] = img[y*axes[0]+x]; // flip the row
		memcpy(&img[y*axes[0]], row, sizeof(float) * axes[0]); // copy the flipped row back to the image
	}

	free(row);
	return 0;
}

// in place image rotate 180 deg
int image_invert(float *buf, long axes[2])
{
	long x, y;
	float *tbuf;

	tbuf = (float *) malloc(sizeof(float) * axes[0]*axes[1]);

	for (y = 0; y < axes[1]; y++)
		for (x = 0; x < axes[0]; x++)
			tbuf[(axes[1]-y-1)*axes[0]+(axes[0]-x-1)] = buf[y*axes[0]+x];

	memcpy(buf, tbuf, sizeof(float) * axes[0]*axes[1]); 

	free(tbuf);
	return 0;
}


// Handle CFITSIO status reports
int handle_status(int *status, int warning, const char *msg)
{
	char s[FLEN_ERRMSG];
	int stat;
	stat = *status;
	if (stat) {
		while (fits_read_errmsg(s))
			fprintf(stderr, "%s (%d): %s\n", warning ? "WARNING" : "ERROR", stat, s);
		if (!warning) {
			fprintf(stderr, "FATAL: %s (status = %d), exiting...\n", msg, stat);
			exit(stat);
		}
	}
	*status = 0;
	return stat;
}


// return pointer to pixel at coordinate x,y (starting from 0,0) in top left of image
float *get_pixel(float *image, long x, long y, long axes[2])
{
	if ((x < 0) || (x >= axes[0]))
		return NULL;
	if ((y < 0) || (y >= axes[1]))
		return NULL;
	return &(image[x+y*axes[0]]);
}


static int fsortfunc(const void *x1, const void *x2)
{
	return ( *( (float *) x1) > *( (float *) x2) ) ? 1 : -1;
}


// determine median of array of size n (non-destructive)
float median(float inp[], int n)
{
	float *vals, med;
	int i;
	vals = (float *) malloc(sizeof(float)*n);
	for (i = 0; i < n; i++)
		vals[i] = inp[i];
	qsort(vals, n, sizeof(float), fsortfunc); // sort to ascending order
	med = vals[n/2];
	free(vals);
	return med;
}

// return RMS of values below zero, assumes mean of zero
float rmsneg(float inp[], int n, float offset)
{
	float val;
	double sum=0;
	int i, ct=0;

	for (i = 0; i < n; i++) {
		val = inp[i] - offset;
		if (val < 0) {
			sum += val * val;
			ct++;
		}
	}
	if (ct)
		return (float) sqrt(sum/ct);
	else
		return 0;
}


// determine mean of the lowest x %  of an array of size n (non-destructive)
float mean_min(float inp[], int n, float x)
{
	float *vals;
	float mean;
	int i, ct;
	vals = (float *) malloc(sizeof(float)*n);
	for (i = 0; i < n; i++)
		vals[i] = inp[i];
	qsort(vals, n, sizeof(float), fsortfunc); // sort to ascending order
	ct = (int) floor(n * x + 0.5);
	mean = 0;
	for (i = 0; i < ct; i++)
		mean += vals[i];
	free(vals);
	return mean/ct;
}



// determine image stats
int stats(float inp[], long axes[2], float level[], int steps)
{
	float *vals;
	int i;
	long size;
	int lev;
	size = axes[0] * axes[1];
	vals = (float *) malloc(sizeof(float)*size);
	for (i = 0; i < size; i++)
		vals[i] = inp[i];
	qsort(vals, size, sizeof(float), fsortfunc); // sort to ascending order

	for (i = 0; i < steps; i++) {
		lev = i * size / (steps-1);
		if (lev >= size)
			lev = size-1;
		level[i] = vals[lev];
	}
	free(vals);
	return 0;
}


// determine sky level of array (non-destructive)
float skylevel(float inp[], long axes[2], float nsigma)
{
	float *vals, med, sky;
	float rms;
	int i;
	int ct;
	int n = axes[0] * axes[1];

	vals = (float *) malloc(sizeof(float)*n);
	for (i = 0; i < n; i++)
		vals[i] = inp[i];

	// first determine the median
	qsort(vals, n, sizeof(float), fsortfunc);
	med = vals[n/2];

#if 0
	// then estimate the RMS using pixels below the median only
	rms = 0;
	for (i = 0; i < n/2; i++)
		rms += powf((vals[i]-med),2);
	rms = sqrtf(rms/(n/2));

	// then calculate the  mean using pixels within nsigma * RMS of median
	// FIXME - This is not a good approach since 1-sigma below the median is asymmetric relative to above
	// For now just use the median
	ct = 0;
	sky = 0;
	for (i = 0; i < n/2; i++) {
		if (fabsf(vals[i]-med) < (nsigma*rms)) {
			sky += vals[i];
			ct++;
		}
	}
#endif
	free(vals);
	// return sky/ct;
	return med;
}

// estimate the image noise level by calculting the RMS of negative pixels.
// ignores pixels within border of the edge
float rms_sky(float *img, long axes[2], float background, int border)
{
	double sumsq = 0;
	long i;
	long x,y;
	unsigned ct = 0;
	for (y = border; y < (axes[1]-border); y++) {
		for (x = border; x < (axes[0]-border); x++) {
			i = y * axes[0] + x;
			if ((img[i]-background) <= 0) {
				sumsq += pow(img[i]-background, 2.0);
				ct++;
				// printf("RMSsky %6ld %6d %.4f\n", i, ct, img[i]-background);
			}
		}
	}
	if (ct > 0)
		return (float) sqrt(sumsq/ct);
	else
		return -1;
}

// generate a Gaussian noise sample
float noise(float sd)
{
	float x;
	float noise, noiseph;
	do {
			x = (float) rand() / (float) RAND_MAX;
	} while (x == 0);
	noise = sd * sqrtf(-logf(x)); /* noise amplitude */
	noiseph = (float) (2 * M_PI * (float) rand() / (float) RAND_MAX); /* noise phase */
	return noise * cosf(noiseph);
}

// add zero mean Gaussian noise of SD to an image
void add_noise(float *img, long axes[2], float sd)
{
	long i;
	for (i = 0; i < axes[0] * axes[1]; i++)
		img[i] += noise(sd);
}

// print a row from an image
void dumpline(float *buf, long axes[], long line)
{
	unsigned i;
	unsigned start, end;

	start = axes[0] * line;
	end = start + axes[0];

	for (i = start; i < end; i++)
		printf("LINE %3ld: %8.2f\n", line, buf[i]);
}

// print an area from an image
void dumparea(float *buf, long axes[], int start[], int r)
{
	long x, y;

	for (y = start[1] - r; y <= start[1] + r ; y++) {
		for (x = start[0] - r; x <= start[0] + r ; x++) {
			printf("%5.0f ", buf[y*axes[0]+x]);
		}
		printf("\n");
	}
}

// determine the 1 dimensional centroid
float centroid1d(float *buf, float sky, int rows, int wid, double *cent, double r, int debug_cen)
{
	// float sum;
	int x, y, idx;
	float sum1, sum2;
	float dx;
	float val;
	int icent;
	int lim;

	icent = (int) floor(*cent+0.5); // nearest integer for centroid
	lim = (int) floor(2*r + 0.5);

	sum1 = sum2 = 0;
	for (y = 0; y < rows; y++) {
		for (x = -lim; x <= lim; x++) {
			idx = icent + x;
			val = buf[y*wid+idx] - sky;
			if (val < 0)
				val = 0;
			if (debug_cen)
				printf("CEN1 %4d %4d %6.1f %6.1f %4d\n", y, idx, val, sky, icent);
			sum1 += val;
			sum2 += x * val;
		}
	}
	if (sum1 > 0)
		dx = sum2/sum1;
	else
		dx = 0;
	*cent = icent + dx;
	icent = (int) floor(*cent+0.5);

	if (debug_cen)
		printf("CEN2 %7.1f %7.1f %5.2f %6.2f\n", sum1, sum2, dx, *cent);

	sum1 = 0;
	lim = (int) floor(r + 0.5);
	for (y = 0; y < rows; y++) {
		for (x = -lim; x <= lim; x++) {
			idx = icent + x;
			val = buf[y*wid+idx] - sky;
			sum1 += val;
		}
	}

	return sum1;
}

// determine the 2-D centroid
float centroid2d(float *buf, float sky, long axes[2], double centre[2], double r)
{
	float sum, sumy, sumx;
	float ycent, xcent;
	long x, y;
	float *pix, maxpix;

	maxpix = -1e8;
	sum = sumx = sumy = 0;
	for (y = (int) floor(centre[1] - r); y <= (int) ceil(centre[1] + r) ; y++) {
		for (x = (int) floor(centre[0] - r); x <= (int) ceil(centre[0] + r) ; x++) {
			pix = get_pixel(buf, x, y, axes);
			if (pix) {
				float val = *pix - sky;
				if (*pix > maxpix)
					maxpix = *pix;
				sum += val;
				sumy += (y - centre[1]) * val;
				sumx += (x - centre[0]) * val;
			}
		}
	}
	ycent = sumy/sum;
	xcent = sumx/sum;
	centre[0] += xcent;
	centre[1] += ycent;
	return maxpix;
}




// determine the 2-D centroid
void find_centroid(float *buf, long axes[2], long start[2], int r)
{
	float sum, sumy, sumx;
	float ycent, xcent;
	long x, y;
	float *pix;

	sum = sumx = sumy = 0;
	for (y = start[1] - r; y <= start[1] + r ; y++) {
		for (x = start[0] - r; x <= start[0] + r ; x++) {
			pix = get_pixel(buf, x, y, axes);
			if (pix) {
				sum += *pix;
				sumy += (y - start[1]) * (*pix);
				sumx += (x - start[0]) * (*pix);
			}
		}
	}
	ycent = sumy/sum;
	xcent = sumx/sum;

	//start[0] += nint(xcent);
	//start[1] += nint(ycent);

//	printf("\nfind_centroid():  %.2f %.2f %4d %4d %.2f %.2f %.2f\n", xcent, ycent, start[0], start[1], sumx, sumy, sum);

#if 0
	for (y = -r; y <= r ; y++) {
		for (x = -r; x <= r ; x++)
			printf("%5.0f ", buf[(y+start[1])*axes[0]+(x+start[0])]);
		printf("\n");
	}
#endif
	start[0] += nint(xcent);
	start[1] += nint(ycent);

#if 0
	printf("======\n");
	for (y = -r; y <= r ; y++) {
		for (x = -r; x <= r ; x++)
			printf("%5.0f ", buf[(y+start[1])*axes[0]+(x+start[0])]);
		printf("\n");
	}
#endif

}

// determine level clip limits depending on proportion of pixels clipped
void cliplimits(float *buf, long axes[], float clip, float *min, float *max, int cliptype)
{
	float *tmp;
	int i;
	long size;

	size = axes[0] * axes[1];
	// allocate temporary image buffer and copy image
	if ((tmp = (float *) malloc(sizeof(float) * size)) == NULL) {
		fprintf(stderr, "Couldn't allocate temporary buffer\n")	;
		exit(5);
	}
	for (i = 0; i < size; i++)
		tmp[i] = buf[i];

	qsort(tmp, size, sizeof(float), fsortfunc); // sort to ascending order
	switch (cliptype) {
	case 0:
	default:
		*min = tmp[(unsigned) floor(clip*size)];
		*max = tmp[(unsigned) floor((1-clip)*size)-1];
		break;
	case 1:
		*max = tmp[(unsigned) floor(0.99*size)-1];
		*min = tmp[(unsigned) floor((0.5-clip)*size)];
		break;
	case 2:
		*min = tmp[(unsigned) floor(6*clip*size)];
		*max = tmp[(unsigned) floor((1-clip)*size)-1];
		break;
	}
	free(tmp);
}



float subtract_sky(float *buf, long axes[], float *rms)
{
	float *tmp;
	int i;
	long size;
	double mean, sum;
	int used;

	size = axes[0] * axes[1];

	// allocate temporary image buffer and copy image
	if ((tmp = (float *) malloc(sizeof(float) * size)) == NULL) {
		fprintf(stderr, "Couldn't allocate temporary buffer\n")	;
		exit(5);
	}
	for (i = 0; i < size; i++)
		tmp[i] = buf[i];

	// first determine the median
	qsort(tmp, size, sizeof(float), fsortfunc); 

	// Then the mean assuming that 10% of the image pixels around the median are sky
	sum = 0;
	used = 0;
	for (i = -size/20; i < size/20; i++) {
		sum += tmp[i + size/2];
		used++;
	}
	mean = sum/used;

	for (i = 0; i < size; i++)
		buf[i] -= (float) mean; // subtract estimated sky level from the image

	// use negative pixels to estimate RMS sky noise
	if (rms) {
		sum = 0;
		used = 0;
		for (i = 0; i < size; i++) {
			if (buf[i] < 0) {
				sum += sqr(buf[i]);
				used++;
			}
		}
		*rms = (float) sqrt(sum/used);
	}

	free(tmp);

	return (float) mean;
}


double aperture(float *buf, long axes[], double centroid[], int radius)
{
	long x, y;
	double dx, dy, sum, sumx, sumy;
	int iteration;
	double count;

	for (iteration = 0; iteration < 6; iteration++) {
		// printf("Iteration %d, centroid %.2f %.2f\n", iteration, centroid[0], centroid[1]);
		sum = sumx = sumy = 0;
		count = 0;
		for (y = (long) floor(centroid[1] - 1.5*radius); y <= (long) floor(centroid[1]+1.5*radius); y++) {
			for (x = (long) floor(centroid[0] - 1.5*radius); x <= (long) floor(centroid[0]+1.5*radius); x++) {
				dx = x - centroid[0];
				dy = y - centroid[1];
				sum += buf[y*axes[0]+x];
				sumx += dx * buf[y*axes[0]+x];
				sumy += dy * buf[y*axes[0]+x];
				if (sqrt(sqr(dx)+sqr(dy)) <= radius) {
					//printf("%6.1f ", buf[y*axes[0]+x]);
					count += buf[y*axes[0]+x];
				} else {
					//printf("       ", buf[y*axes[0]+x]);
				}
				//printf("%6.1f ", buf[y*axes[0]+x]);
			}
			//printf("   PIX\n");
		}
		centroid[0] += sumx/sum;
		centroid[1] += sumy/sum;

	}
	for (y = (long) floor(centroid[1] - 1.5*radius); y <= (long) floor(centroid[1]+1.5*radius); y++) {
		for (x = (long) floor(centroid[0] - 1.5*radius); x <= (long) floor(centroid[0]+1.5*radius); x++) {
			dx = x - centroid[0];
			dy = y - centroid[1];
	//		printf("PROF %.3f %.3f\n", sqrt(sqr(dx)+sqr(dy)), buf[y*axes[0]+x]);
		}
	}

//	printf("Centroid: %.2f %.2f %.2f\n", centroid[0], centroid[1], count);
	return count;
}


static int compfunc(const void *e1, const void *e2)
{
	float *p1, *p2;
	p1 = (float *) e1;
	p2 = (float *) e2;
	return (*p2 < *p1) ? 1 : -1;
}

float combine_minpix(int n, float buf[])
{
	qsort(buf, n, sizeof(float), compfunc);
	return buf[0];
}

float combine_maxpix(int n, float buf[])
{
	qsort(buf, n, sizeof(float), compfunc);
	return buf[n-1];
}

// return the mean of an n-point array excluding outliers. Done in place
float mean_removeoutliers(int n, float buf[], int noremove, int verbose)
{
	int i;
	double m, s, std, mean, m0, m1, s1, s2, err;
	double t0, t1, c = 1.5;

	mean = 0;
	for (i = 0; i < n; i++)
		mean += buf[i];
	m0 = mean/n;

	if (noremove)
		return (float) m0;

	if (verbose > 1) {
		printf("A %7.2f ", m0);
		for (i = 0; i < n; i++)
			printf("%5.0f ", buf[i]);
		printf("\n");
	}

	// sort set and determine median
	qsort(buf, n, sizeof(float), compfunc);
	m = buf[n/2];

	if (verbose > 1) {
		printf("B %7.2f ", m);
		for (i = 0; i < n; i++)
			printf("%5.0f ", buf[i]);
		printf("\n");
	}

	// calculate std based on median
	std = 0;
	for (i = 0; i < n; i++)
		std += sqr(buf[i]-m);
	s = sqrt(std/n);

	do {

		t0 = m - c*s;
		t1 = m + c*s; // limits
#if 1
		// winsorize the set
		for (i = 0; i < n; i++) {
			if (buf[i] < t0)
				buf[i] = (float) t0;
			if (buf[i] > t1)
				buf[i] = (float) t1;
		}
#endif

#if 0
		for (i = 0; i < n; i++) {
			if (buf[i] < t0)
				buf[i] = m;
			if (buf[i] > t1)
				buf[i] = m;
		}
#endif

		// calculate mean and std of new set (m1, s1)
		mean = 0;
		for (i = 0; i < n; i++)
			mean += buf[i];
		m1 = mean/n;
		std = 0;
		for (i = 0; i < n; i++)
			std += sqr(buf[i]-m1);
		s1 = sqrt(std/n);

		s2 = 1.134*s1; // assume normal distribution and c = 1.5

		err = fabs(s2 - s)/s;

		// printf("%.2f %.2f %.2f %.2f %.2f %.2f %.5f\n", m, s, t0, t1, m1, s1, err);

		m = m1;
		s = s2;

	} while (err > 0.002);

	if (verbose > 1) {
		printf("C %7.2f ", m1);
		for (i = 0; i < n; i++)
			printf("%5.0f ", buf[i]);
		printf("=====\n");
	}

	return (float) m;
}

// Apply a filter to an image. Return a pointer to the result
float *img_filt(float *img, long axes[], int rad, FILTTYPE type)
{
	long x,y;
	long i, j;
	int n;

	float *res;
	float *list;
	float *ptr;

	res = (float *) malloc(sizeof(float) * axes[0] * axes[1]); // output image
	list = (float *) malloc(sizeof(float) * (2*rad+1) * (2*rad+1)); // array to hold pixel data

	for (x = 0; x < axes[0]; x++) {
		for (y = 0; y < axes[1]; y++) {
			n = 0;
			for (i = -rad; i <= rad; i++) {
				for (j = -rad; j <= rad; j++) {
					ptr = get_pixel(img, x+i, y+j, axes);
					if (ptr)
						list[n++] = *ptr;

				}
			}
			if (n == 0) {
				res[y*axes[0]+x] = 0;
				continue;
			}
			switch (type) {
			case FILT_MEANMIN:
				res[y*axes[0]+x] = mean_min(list, n, 0.1f);
				break;
			case FILT_MEDIAN:
				res[y*axes[0]+x] = median(list, n);
				break;
			case FILT_SIGCLIP:
				res[y*axes[0]+x] = mean_removeoutliers(n, list, 0, 0);
				break;
			default:
				res[y*axes[0]+x] = 0;
				break;
			}


		}
	}

	free(list);
	return res;
}

// Generate a median tile image with tiles of size n
float *img_medtile(float *img, long axes[], int n)
{
	int x, y, x1, y1;
	int i;
	float *res, *tile, *ptr;
	float val;
	res = (float *) malloc(sizeof(float) * axes[0] * axes[1]);
	tile = (float *) malloc(sizeof(float) * n * n);

	for (y = 0; y < axes[1]; y += n) {
		for (x = 0; x < axes[0]; x += n) {
			i = 0;
			for (y1 = 0; y1 < n; y1++) {
				for (x1 = 0; x1 < n; x1++) {
					ptr = get_pixel(img, x+x1, y+y1, axes);
					if (ptr)
						tile[i++] = *ptr;
				}
			}
			val = median(tile, i);
			for (y1 = 0; y1 < n; y1++) {
				for (x1 = 0; x1 < n; x1++) {
					ptr = get_pixel(res, x+x1, y+y1, axes);
					if (ptr)
						*ptr = val;
				}
			}
		}
	}
	free (tile);
	return res;
}

int aperture_photom(float *img, long axes[2], PHOTOM_APER *ap)
{
	float *skybuf;
	long x, y;
	int lim;
	double r;
	float *ptr;
	int ct1=0, ct2=0;

	if ((ap->r2 <= ap->r1) || (ap->r1 < 2))
		return -1;

	if (ap->centroid)
		find_centroid(img, axes, ap->centre, (int) ceil(ap->r1));

	lim = (int) ceil(ap->r2);
	skybuf = (float *) malloc(sizeof(float) * 4 * lim * lim);
	ap->sky = ap->counts = 0;
	for (y = ap->centre[1]-lim; y <= ap->centre[1]+lim; y++) {
		for (x = ap->centre[0]-lim; x <= ap->centre[0]+lim; x++) {
			ptr = get_pixel(img, x, y, axes);
			if (ptr) {
				r = sqrt(pow(y - ap->centre[1], 2) + pow(x - ap->centre[0], 2));
				if (r < ap->r1) {
					ap->counts += *ptr; // in aperture so count
					ct1++;
				} else {
					skybuf[ct2++] = *ptr; // outside aperture so add to sky buffer
				}
			}
		}
	}
	if (ct2) {
		ap->sky = median(skybuf, ct2); // calculate sky from median of surrounding pixels
		ap->counts -= ap->sky * ct1; // remove sky
	}

	free(skybuf);	

	return 0;
}

int asinh_stretch(float *buf, long axes[2], double a, double Q, float *min, float *max)
{
	float skylevel, rms, pix, maxpix;
	long i;

	if (*min == 0) {
		skylevel = median(buf, axes[0]*axes[1]);
		rms = rms_sky(buf, axes, skylevel, 10);	
		skylevel -= 1 * rms;
		maxpix = 1e10;
	} else {
		skylevel = *min;
		maxpix = *max;
	}

	*min = *max = 0;

	for (i = 0; i < axes[0]*axes[1]; i++) {
		pix = buf[i] - skylevel;
		if (pix < 0)
			pix = 0;
		if (pix > maxpix)
			pix = maxpix;
		pix = (float) asinh(a * Q * pix) / Q;
		if (pix > *max)
			*max = pix;
		buf[i] = pix;
	}
	return 0;

}


int logsqrt_stretch(float *buf, long axes[2], float *min, float *max)
{
	float skylevel, rms, pix, maxpix;
	long i;

	if (*min == 0) {
		skylevel = median(buf, axes[0]*axes[1]);
		rms = rms_sky(buf, axes, skylevel, 10);	
		skylevel += 1 * rms;
		maxpix = 1e10;
	} else {
		skylevel = *min;
		maxpix = *max;
	}

	*min = *max = 0;

	for (i = 0; i < axes[0]*axes[1]; i++) {
		pix = buf[i] - skylevel;
		if (pix < 1)
			pix = 1;
		if (pix > maxpix)
			pix = maxpix;
		pix = logf(sqrtf(pix));
		if (pix > *max)
			*max = pix;
		buf[i] = pix;
	}
	return 0;
}

// Perform a polynomial surface fit
int fit_gradient(float *buf, long axes[], int order, int iterations)
{
	FILTER *gfilt;
	float *tbuf;
	float skyval, rms;
	const double filtrad = 3.0;
	double th1, th2;
	int ct1, ct2;
	long i;

	gfilt = gen_filter(FILT_GAUSSIAN, filtrad);
	tbuf = filter(buf, axes, gfilt, 0); // obtain a smoothed copy of the input image
	skyval = median(tbuf, axes[0]*axes[1]);
	rms = rms_sky(tbuf, axes, skyval, (int) floor(6*filtrad));
	ct1 = ct2 = 0;
	th1 = skyval + rms;
	th2 = skyval + 2 * rms;
	for (i = 0; i < axes[0]*axes[1]; i++) {
		if (tbuf[i] > th1)
			ct1++;
		if (tbuf[i] > th2) {
			ct2++;
			tbuf[i] = 3000;
		} else
			tbuf[i] = 1000;
	}
	printf("Iteration 1: sky = %.2f, rms = %.2f %ld %d %d\n", skyval, rms, axes[0]*axes[1], ct1, ct2);

	memmove(buf, tbuf, axes[0]*axes[1]*sizeof(float)); // !!!! FIXME

	free(gfilt->coef);
	free(gfilt);
	free(tbuf);


	return 0;
}


static float *_filter(float *buf, long axes[], FILTER *filt, int inplace)
{
	float *obuf;
	float *ipix, *opix;
	long x, dx, y, dy;
	long midx, midy;

	obuf = (float *) malloc(sizeof(float)*axes[0]*axes[1]);	
	midx = filt->n1/2;
	midy = filt->n2/2;
	for (y = 0; y < axes[1]; y++) {
		for (x = 0; x < axes[0]; x++) {
			opix = get_pixel(obuf, x, y, axes); // output pixel pointer
			if (opix) {
				*opix = 0;
				for (dy = 0; dy < filt->n2; dy++) {
					for (dx = 0; dx < filt->n1; dx++) {
						ipix = get_pixel(buf, x+dx-midx, y+dy-midy, axes); // input pixel pointer
						if (ipix)
							*opix += *ipix * (float) filt->coef[dy*filt->n1 + dx];
					}
				}
			}
		}
	}

	if (inplace) {
		memmove(buf, obuf, sizeof(float)*axes[0]*axes[1]);
		free(obuf);
		obuf = buf;
	}
	return obuf;
}

float *filter(float *buf, long axes[], FILTER *filt, int inplace)
{
	float *tbuf;
	FILTER nfilt;

	tbuf = _filter(buf, axes, filt, inplace); // First pass
	if (filt->separable) { // 2D filter implemented as two 1D passes
		nfilt.n1 = filt->n2;
		nfilt.n2 = filt->n1; // swap coordinates
		nfilt.coef = filt->coef;
		tbuf = _filter(tbuf, axes, &nfilt, 1); // Second pass is always in place
	}
	return tbuf;
}

FILTER *gen_filter(FILTERTYPE ft, double param1)
{
	FILTER *filt;

	filt = (FILTER *) malloc(sizeof(FILTER));

	switch(ft) {
	case FILT_GAUSSIAN: // Gaussian filter (separable)
		{
		double sigma = param1;
		double sum = 0;
		double dr2;
		int dim;
		int x, dx;
		dim = (int) ceil(5*sigma);
		filt->n1 = 2 * dim + 1;
		filt->n2 = 1;
		filt->coef = (double *) malloc(sizeof(double) * filt->n1 * filt->n2); // coefficient storage
		for (x = 0; x < filt->n1; x++) {	
			dx = x - dim;
			dr2 = (dx*dx) / (2 * pow(sigma,2));
			filt->coef[x] = (1 / (sqrt(2*M_PI) * sigma)) *  exp(-dr2);
			sum += filt->coef[x];
		}
		for (x = 0; x < filt->n1; x++)
			filt->coef[x] /= sum;
		filt->separable = 1; // indicates that the 2D filter can be done in two passes of 1D filtering
		}
		break;
	default:
		free(filt);
		return NULL;
	}

	return filt;
}

// replace pixels n sigma below sky level with median of local area
// Filter frame but only replace pixels within n sigma of sky level
// Median filter but only replace pixels if they exceed some measure of distance from mean.
float *denoise(float *buf, long axes[], float skylev, float skyrms, int inplace, float sigma)
{
	float *tbuf;
	const int mrad = 1;
	long i;
	int keep;


	tbuf = img_filt(buf, axes, mrad, FILT_MEDIAN);
	if (tbuf == NULL)
		return NULL;

	for (i = 0; i < axes[0]*axes[1]; i++) {
		keep = 1;
		if (buf[i] < (skylev + sigma*skyrms)) // pixels below a threshold
			keep = 0;
		if ((buf[i] - tbuf[i]) > (3 * skyrms)) // pixels much brighter than local area
			keep = 0;
		if (keep)
			tbuf[i] = buf[i];

	}


	if (inplace) {
		memmove(buf, tbuf, axes[0]*axes[1]*sizeof(float));
		free(tbuf);
		return buf;
	}
	return tbuf;
}



// Bin image nxn
float *binning(float *buf, long axes[2], int bin) 
{
	float *tgt;
	long new_axes[2];
	long x, y, x1, y1;

	new_axes[0] = axes[0]/bin;
	new_axes[1] = axes[1]/bin;

	tgt = (float *) calloc(sizeof(float), new_axes[0] * new_axes[1]); // allocate binned image buffer
	if (tgt == NULL) {
		fprintf(stderr, "Cannot allocated binned memory buffer\n");
		return NULL;
	}

	// Do the binning
	for (y = 0; y < new_axes[1]; y++) {
		for (x = 0; x < new_axes[0]; x++) {
			for (y1 = bin*y; y1 < bin*y+bin; y1++) {
				for (x1 = bin*x; x1 < bin*x+bin; x1++) {
					tgt[y*new_axes[0]+x] += buf[y1*axes[0]+x1];
				}
			}
		}
	}

	axes[0] = new_axes[0];
	axes[1] = new_axes[1];
	free(buf);
	return tgt;
}

// Shift and combine n images with optional drizzle and return output
// If the shift list is null it is not used
float *stack_images(int n, float *images[], long axes[2], int drizzle, COORD shiftlist[], COMBINE_TYPE type, int verbose)
{
	int tgt_x, tgt_y;
	int src_x, src_y;
	int shift_x, shift_y;
	int image;
	int tgt_pixel, src_pixel;
	float *pbuf, *obuf;
	int used;
	COORD shift;
	const int stepsize = 1; //!!!!! FIXME

	pbuf = (float *) malloc(sizeof(float) * n); // buffer to store pixels for each point
	obuf = (float *) malloc(sizeof(float) * axes[0] * axes[1] * drizzle * drizzle); // buffer for the output image

	// Now combine all the images
	for (tgt_y = 0; tgt_y < axes[1]*drizzle; tgt_y++) {
		for (tgt_x = 0; tgt_x < axes[0]*drizzle; tgt_x++) { // loop through the target pixels
			used = 0; // count of pixels to stack

			for (image = 0; image < n; image++) {
				if (shiftlist)
					shift = shiftlist[image];
				else {
					shift.x = shift.y = 0;	
					shift.type = COORD_USE;
				}
				shift_x = stepsize * (int) floor(drizzle*shift.x/stepsize+0.5);
				shift_y = stepsize * (int) floor(drizzle*shift.y/stepsize+0.5);
				// if ((tgt_y ==0) && (tgt_x == 0))
				// 	printf("stack_images %d %d\n", shift_x, shift_y);
				src_x = tgt_x + shift_x;
				src_y = tgt_y + shift_y;
				src_pixel = (src_y/drizzle) * axes[0] + (src_x/drizzle); // source pixel
				if ((src_pixel >= 0) && (src_pixel < axes[0]*axes[1]) && (shift.type == COORD_USE))
					pbuf[used++] = images[image][src_pixel]; // pixel values for this stack
			}

			tgt_pixel = tgt_y*axes[0]*drizzle + tgt_x; // pixel in output image

			switch (type) {
			case COMBINE_MIN:
				obuf[tgt_pixel] = combine_minpix(used, pbuf);
				break;
			case COMBINE_MAX:
				obuf[tgt_pixel] = combine_maxpix(used, pbuf);
				break;
			case COMBINE_MEDIAN:
				obuf[tgt_pixel] = median(pbuf, used);
				break;
			case COMBINE_CLIP:
				obuf[tgt_pixel] = mean_removeoutliers(used, pbuf, 0, verbose);
				break;
			case COMBINE_MEAN:
				obuf[tgt_pixel] = mean_removeoutliers(used, pbuf, 1, verbose);
				break;
			default:
				obuf[tgt_pixel] = 0;
				break;
			}
		}
	}
	free(pbuf);
	return obuf;
}

float *shift_and_subtract(float *im1, float *im2, long axes[2], float sky, COORD shift)
{
	float *res;
	long x,y;
	long sub_x, sub_y;
	long shift_x, shift_y;
	float *r, *a, *b;

	res = (float *) malloc(sizeof(float) * axes[0] * axes[1]);
	if (res == NULL)
		return NULL;

	// sky = median(im2, axes[0]*axes[1]);
	shift_x = (long) floor(shift.x+0.5);
	shift_y = (long) floor(shift.y+0.5);
	// printf("shift and subtract %d %d\n", shift_x, shift_y);

	for (y = 0; y< axes[1]; y++) {
		for (x = 0; x < axes[0]; x++) {
			sub_x = x + shift_x;
			sub_y = y + shift_y;

			r = get_pixel(res, x, y, axes);
			a = get_pixel(im1, x, y, axes);
			b = get_pixel(im2, sub_x, sub_y, axes);
			if ((a==NULL) || (b==NULL)) {// out of image
				*r = 0;
			} else {
				*r = *a - *b;
			}
			//if (*r < 0)
			//	*r = 0;
			*r += sky;
		}
	}

	return res;
}



// Clip stack on stars
// Subtract result from input images
// Clip stack on comet
// iterate?

float *comet_stack(int n, float *images[], long axes[2], COORD starshift[], COORD cometshift[], int iterations, int verbose)
{
	float *stars=NULL, *comet=NULL;
	float **temp=NULL; // temporary image buffers
	int i;
	int iteration;
	float sky;

	FITSDESC fd; // debugging
	char name[MAXLEN];

	fd.bitpix = USHORT_IMG;
	fd.comment = "Comet stack";

	if (starshift == NULL)
		return NULL;
	if (cometshift == NULL)
		return NULL;

	for (i = 0; i < n; i++) {
		cometshift[i].x += starshift[i].x;
		cometshift[i].y += starshift[i].y;
		cometshift[i].type = starshift[i].type;
		// printf("%3d: Comet %5.1f %5.1f Star %5.1f %5.1f\n", i, cometshift[i].x, cometshift[i].y, starshift[i].x, starshift[i].y);
	}

	temp = (float **) malloc(sizeof(float *) * n); // image buffer pointers

	// stars = stack_images(n, images, axes, 1, starshift, COMBINE_CLIP, verbose); // initial stack on stars
	stars = stack_images(n, images, axes, 1, starshift, COMBINE_MEDIAN, verbose); // initial stack on stars
	if (stars == NULL)
		return NULL;
	if (verbose)
		write_as_new_fits(stars, axes, "!star_xxx.fit", &fd);

	for (iteration = 0; iteration < iterations; iteration++) {

		sky = median(stars, axes[0]*axes[1]);
		// printf("Median sky %f\n", sky);
		// Subtract stars from the input images
		for (i = 0; i < n; i++) {
			COORD shift;
			shift.x = -starshift[i].x;
			shift.y = -starshift[i].y;
			temp[i] = shift_and_subtract(images[i], stars, axes, sky, shift);
			// sprintf(name, "!tempstar_%02d_%02d.fit", iteration, i);
			// write_as_new_fits(temp[i], axes, name, &fd);

			// printf("%3d: Median image after star removal is %f\n", i,  median(temp[i], axes[0]*axes[1]));
		}
	
		// Then stack resulting images on comet
		if (comet)
			free(comet);
		comet = stack_images(n, temp, axes, 1, cometshift, iteration ? COMBINE_CLIP : COMBINE_MEDIAN, verbose);
		if (comet == NULL)
			return NULL;
		if (verbose) {
			sprintf(name, "!comet_%02d.fit", iteration);
			write_as_new_fits(comet, axes, name, &fd);
		}
		for (i = 0; i < n; i++) // No need for these images any more
			free(temp[i]);	
	
		sky = median(comet, axes[0]*axes[1]);
		// Subtract comet from the input images
		for (i = 0; i < n; i++) {
			COORD shift;
			shift.x = -cometshift[i].x;
			shift.y = -cometshift[i].y;
			temp[i] = shift_and_subtract(images[i], comet, axes, sky, shift);
			// sprintf(name, "!tempcomet_%02d_%02d.fit", iteration, i);
			// write_as_new_fits(temp[i], axes, name, &fd);
			
		}

		// then stack resulting images on stars
		if (stars)
			free(stars);
		stars = stack_images(n, temp, axes, 1, starshift, iteration ? COMBINE_CLIP : COMBINE_MEDIAN, verbose);
		if (verbose) {
			sprintf(name, "!stars_%02d.fit", iteration);
			write_as_new_fits(stars, axes, name, &fd);
		}
		if (stars == NULL)
			return NULL;
		for (i = 0; i < n; i++) // No need for these images any more
			free(temp[i]);	
	}

	image_add(stars, comet, axes, 1);
	free(comet);

	return stars;
}

// Find coordinates of max pixel in range
float max_pixel(float *img, long axes[2], double centre[2], double range)
{
	long ix, iy;
	float max = 0;
	float *p;
	long cx, cy;
	for (iy = (int) floor(centre[1]-range); iy < (int) ceil(centre[1]+range); iy++) {
		for (ix = (int) floor(centre[0]-range); ix < (int) ceil(centre[0]+range); ix++) {
			p = get_pixel(img, ix, iy, axes);
			if (p) {
				if (*p > max) {
					max = *p;
					cx = ix;
					cy = iy;
				}
			}
		}
	}
	centre[0] = cx;
	centre[1] = cy;
	// printf("max_pixel %f %f %f\n", centre[0], centre[1], max);
	return max;
}

 
// track an object from start and update the coordinate list
int track_object(int n, float *images[], long axes[2], float skylevel[], COORD start, double r, COORD shiftlist[], GAUSSFIT *psf)
{
	int i, rc;
	double centre[2];

	centre[0] = start.x;
	centre[1] = start.y;
	for (i = 0; i < n; i++) { // for each image
		shiftlist[i].type = COORD_USE; // use this one by default
		if (start.range > 0) // search for max pixel in the box centred on centre
			max_pixel(images[i], axes, centre, start.range);

		centroid2d(images[i], skylevel[i], axes, centre, r);
		if (psf) {
			rc = gauss_psf(images[i], axes, centre, r, 1.5*r, 2.0*r, psf, 0);
			if (rc < 0)
				fprintf(stderr, "Gauss fit failed %d\n", rc);
			shiftlist[i].psf_max = psf->A;
			shiftlist[i].psf_fwhm = psf->SD;
			shiftlist[i].psf_sky = psf->sky;
			if (psf->SD > psf->reject) // 
				shiftlist[i].type = COORD_REJECT; 
			// printf("%5.1f %5.1f %8.1f %5.2f %6.0f | ", centre[0], centre[1], psf->A, psf->SD, psf->sky);
		} else {
			shiftlist[i].psf_max = shiftlist[i].psf_fwhm = shiftlist[i].psf_sky = 0;
		}
		shiftlist[i].x = centre[0] - start.x;
		shiftlist[i].y = centre[1] - start.y;
	}
	return 0;
}

// centre an alignlist around its mean
COORD centre_alignlist(int n, COORD list[])
{
	COORD sum;
	int i;
	sum.x = sum.y = 0;
	for (i = 0; i < n; i++) {
		sum.x += list[i].x;
		sum.y += list[i].y;
	}
	sum.x /= n;
	sum.y /= n;
	for (i = 0; i < n; i++) {
		list[i].x -= sum.x;
		list[i].y -= sum.y;
	}
	return sum;
}

// Fast star finder
// Uses an approach based on https://arxiv.org/ftp/arxiv/papers/0907/0907.1330.pdf
// Divides the image into tiles of size tilesize and finds at most one star in each tile.
// Stars must have max pixels which are less then 0.9x the max pixel in the image
// and a min pixel greater than 
int fast_star_find(float *buf, long axes[2], int tilesize)
{
	float *tile;
	int n = 0;
	int steps = 10;
	float *level;
	float maxth;
	int rc;

	level = (float *) malloc(sizeof(float) * steps);
	rc = stats(buf, axes, level, steps);
	if (rc < 0)
		return rc;
	maxth = 0.9*level[steps-1]; // ensure stars are not saturated
	free(level);

	return n;
}

// in place mirror an image
int mirror_image(float *buf, long axes[2])
{
	long ix, iy;
	float *tmp;

	tmp = (float *) malloc(sizeof(float) * axes[0]); // temporary row storage

	for (iy = 0; iy < axes[1]; iy++) { // do each row
		for (ix = 0; ix < axes[0]; ix++) // read row in reverse
			tmp[axes[0]-ix-1] = *get_pixel(buf, ix, iy, axes);
		for (ix = 0; ix < axes[0]; ix++) // write row back
			*get_pixel(buf, ix, iy, axes) = tmp[ix];
	}
	free(tmp);
	return 0;
}
